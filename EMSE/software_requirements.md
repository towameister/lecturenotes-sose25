# EMSE: Software Requirements 
## Lecture 1: Introduction
### Why Software Requirements?
*„The hardest single part of
building a software system is
deciding precisely what to
build.* - Fred Brooks

- Fixing errors at the requirements stage reduces costs significantly, compared to dragging them through until software operation (curve from 1x at requirements to 150x at production/operational stage, cost increases throughout development process)
- Study by gartner:
- - Common Project failure factors include **incomplete requirements** and no customer requirements
- - Common project success factors include **customer involvment**, and a **clear statement of requirements**

_How can we find out, what the customer requires from our software?_

- Empirical research: **Observation + Data, systematically!**
- - Meaning: What protocol, what data has been collected how, what did you do to remove potential biases? Is there awareness about internal and external biases?
- - Goals: Explore (Understand phenomena and identify problems) and Evaluate (check/improve hypotheses, measure impact)
- - Strategies: Qualitative and Quantitative, both are important, combining them is common (methodological pluralism, triangulation)
- Threats to validity of empirical studies (Seminar)

- Requirements are ever changing, this change must be managed
- You can do too much ("Analysis paralysis")

### Types of Requirements:
- Functional
- - requirements regarding result of behaviour of functions of the systems
- Nonfunctional
- - Not directly related to functional behaviour, phrased as constraints or negative assertions 
- - Constraints
- - - Limit the solution space beyond what is necessary for meeting given functional and quality requirements
- - Quality requirements (ISO 25010)
- -	- Maintainability, Usability, Reliability, Adaptability, Security, Compatibility, Suitability, Performance, Portability...

#### _Requirements is about asking the right questions_
**Questions need to be asked about:** 

- users
- hardware
- performance
- system interfaces
- quality
- environment
- maintenance and operation
- data
- ...

### Requirements engineering
Software engineering is a subset of Systems engineering
Software engineering is a modelling and problem-solving activity, which is knowledge intensive and rationale driven

Definition **Requirement**: “a statement of **what** the system must do, how it must **behave**, the
**properties** it must exhibit, the **qualities** it must possess, and the
**constraints** that the system and its development must satisfy”

Definition **Requirements Engineering** (RE): branch of systems engineering concerned with

- desired **properties** and **constraints** of software-intensive systems
- **goals** to be achieved in the software's environment
- **assumptions** about environment

**Basically: formulating, documenting and maintaining software requirements**

Views on RE: 

- Engineering view: systematic and repeatable techniques that ensure completeness, consistency and relevance of requirements
- Lifecycle view: Discovery of purpose by identifying stakeholders and their needs, documenting them in a way that is amenable to analysis, communication/discussion and implementation
- Knowledge view: making/documenting/dealing with decisions about functionality of a system

Activities of RE:

- Requirements elicitation/development: discovering, understanding the user's needs and constraints
- Requirements analysis: refining needs and constraints, as understood by developers. results in technical specification/analysis model, formal/semiformal notation (UML)
- Requirements specification: clear and precise documentation, end result of elicitation, natural language
- Requirements verification: Ensuring completeness, correctness, consistency and clarity of requirements
- Requirements Management: scheduling, negotiating, coordinating, documenting RE activities


**TODO: Summarize Rest of Subchapter 3 and 4 of Lecture one**


	






